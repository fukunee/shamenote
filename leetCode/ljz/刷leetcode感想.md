# Leetcode-Yllnss

## 实用技巧
- int[]转List 
  List<Integer> list = Arrays.stream(ints).boxed().collect(Collectors.toList());
- 不使用额外空间交换 两个数
  a = a ^ b
  b = a ^ b
  a = a ^ b
  原理：如果 a ^ b = c 则 a ^ c = b   b ^ c = a
- for(Integer num : a) 和 for(int num : a) 效率相差很大，请根据a的类型选择

## 1071.字符串的最大因子（求公因子通用方法）
- 辗转相除
- 更相减损

## 39.组合总和（难写）
- 动态规划（想法简单，代码实现难，对于这道题效率低）
- 回溯+剪枝

## 754.到达终点数字（数学）

 首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:

 步数        能到达的位置
1:          1
2:          3, 1
3:          6, 4, 2, 0
4:          10, 8, 6, 4, 0
5:          15, 13, 11, 9, 7, 5, 3, 1
...
 可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。
记f(n)为第n步能到达的位置，那么有：

max(f(n)) = max(f(n-1)) + n
f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]
如果target可以在第n步达到，那么target一定小于等于max(f(n))且max(f(n))与taget同奇同偶。

aqs

## 877.石子游戏（数学，dp）
很多堆石头【a,b,c,d】，一次拿一堆，但是只能从最左或者最右拿，1先拿，2后，给一个数组表示石头堆，返回一个结果（true，false）表示1是否能赢，数组.length %2 == 2
- 数学想法
 直观看的话，因为数组是偶数，所以一定是一人拿一半，那么总有一半石头总和多，那么只要1采取那种取法，则能稳赢，所以直接 return true;
- 动态规划
 现在假设石头堆书是奇数，那么这道题需要用动态规划：
 设dp(i, j)表示从包括i到包括j的石堆拿石头能得到最大石头数，根据是从左边拿还是右边拿，还写不出来转移方程，因为这个从左还是从右要看2是怎么拿的，所以还需要设置一个表示对手2是怎么拿的维度。
 设dp(i, j).fir 表示1从i-j石堆能取得的最大值，dp(i, j).sec表示2取得的最大值。
 dp(i, j).fir = max{dp(i+1, j).sec+pliles[i],  dp(i, j-1).sec+piles[j]}
 注意这里 是   i+1, j-1    i,j作为最左最右，整个状态方程是一个向外扩张的过程

## 338.比特位计数



