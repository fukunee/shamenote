迭代算法

 - 初始化
	 - 迭代次数是否可计算。
	- 要返回什么。
	 - 迭代中需要哪些变量，其初始值是什么。哪些单次迭代后即可销毁，哪些需要在N个迭代间共享，哪些需要全迭代共享。
 - 迭代体
	 - 变量间如何相互作用并发生改变。
	 - 变量的值如何改变并传递给下一次迭代，改变时是否会因为执行到结尾产生错误。
 - 完成点
	 - 若迭代次数不可计算，则需要详细枚举迭代完成时的各种情况进行分析并写出测试用例。



---



### 递归算法

- **递归算法**指一种通过重复将问题分解为同类的子问题而解决问题的方法。

---

### 字符串

https://www.jianshu.com/p/3d07e9a91430

| 问题序号 | 问题内容                 | 思路解法 |
| -------- | ------------------------ | -------- |
| 344, 541 | 反转字符串               |          |
| 3 | 无重复字符的最长子串 |          |
| 14 | 最长公共前缀         |          |



---



### 链表

https://www.jianshu.com/p/d675288f0b81

 - 定义：链表是非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
 - 构成：链表由一系列结点组成。每个结点包括两个部分：一个是存储数据元素的数据，另一个是存储下一个结点地址的指针。 
 - 优点：
      - 由于不须按顺序存储，链表在插入和移除时可以达到O(1)的复杂度
      - 使用链表结构可以克服数组链表需要预先知道数据大小的缺点
 - 缺点：
      - 访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。
      - 链表由于增加了结点的指针，空间开销大。
 - 类型：
     - 单向链表 A1->A2->A3->A4  (A1.next==A2)
     - 双向链表 A1<->A2<->A3<->A4  (A2.prior==A1)
     - 循环链表 A1->A2->A3->A4->A1  (A4.rear==A1)
     - 双循环链表 A1<->A2<->A3<->A4<->A1  (A1.prior==A4 , A4.rear==A1)

| 问题序号 | 问题内容                 | 思路解法 |
| -------- | ------------------------ | -------- |
| 206 | 反转链表               |          |
| 92 | 反转链表 II |          |
| 141 | 环形链表             |          |
| 142 | 环形链表 II          |          |



---

### 小猫钓鱼

- 定义：在字符串中寻找具有XX特征的最长子串。**包含非XX特征子串的字符串也不满足XX特征。**
- 思路：即以元素Str[i]为尾的子串中符合XX特征的子串，并遍历出最长的一个。
- 遍历：增尾，单步加长尾部元素。切头，切除足够多的头部元素使子串符合XX特征。每次增尾去头操作后都是一个符合XX特征的合法子串。此法可以完全遍历。

| 问题序号 | 问题内容                                                     | 思路解法 |
| -------- | ------------------------------------------------------------ | -------- |
|   3       | 无重复字符的最长子串 |          |



---

### 动态规划法

> 动态规划能够遍历所有解空间并避免重复计算。避免了回溯算法的重复计算。
> 

 - 适用问题：无后效性、重复子问题。
 - 问题类型：
    - 求最优解
    - 求解空间大小。
 - 思维模式：
    - 首先正向思维。用回溯法枚举出解空间。（最优解问题要善用假设缩小解空间）
    - 回溯过程分析。判读是否存在中间状态，同一个中间状态是否出现在了多个解中，多个重复的中间状态间相同的状态可以用什么参数描述。
    - 状态转移分析。用DP(arg)函数定义中间状态,（当arg为某值时，最优解DP为../解空间大小DP为...），并用DP转移方程描述状态间的关系（当arg发生变化时，DP会发生什么变化）。
    - 初始状态分析。绘制状态转移表。
    - 状态转移优化。绘制状态转移流程图。单个arg时，状态转移为一条单链表。多个arg时，状态应呈现树状。判断状态转移顺序（是各个参数嵌套还是同步递增）

| 问题序号           | 问题内容                                                     | 思路解法                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 70, 746            | 爬楼梯问题：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ | 正向思考，每一次选择都是二选一`steps+=1`或`steps+=2`，做k次选择直到`steps==n`，最后计算方法数。这是回溯法，也称试探法，枚举地尝试每一种可能性。我们发现解空间里存在大量相同的部分。所以我们尝试使用逆向思维。到达楼顶最后一步必是n-2或n-1，所以K^n^=K^n-1^+K^n-2^。在我最后一次爬楼梯时我不关心你前面具体怎么爬的，告诉我你爬了多少种就可以了。 |
| 62, 63, 980        | 不同路径问题：一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，有多少条路径。 | 思路：这个问题和爬楼梯类似。使用回溯法依旧可以完美地解出问题。但是同样的，解空间里重复性过高。尝试逆向思维。到达终点要么是向下要么是向右，即K^i,j^=K^i-1,j^+K^i,j-1^。同时将（i，j）为障碍的K置0即可。 |
| 72, 161            | 编辑距离：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符，删除一个字符，替换一个字符 | 这个问题上来就让人摸不着头脑，万能回溯法似乎不好使。果断逆向思考。我们假设DP(i,j)为wordA的前i位与wordB的前j位相同的情况下最少的操作次数。那么DP(i,j)=1+Math.min(DP(i,j+1), DP(i-1,j), DP(i-1,j-1)) (WA^i^ !== WB^j^) DP(i,j)=DP(i-1, j-1) (WA^i^ === WB^j^)。 |
| 121, 122, 123, 188 | 买卖股票的最佳时机IV：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意: 你必须在再次购买前出售掉之前的股票。 | 这个问题上来就让人摸不着头脑，万能回溯法似乎不好使。果断逆向思考。在i日第k笔卖出的最优收益是i日前某日进行的第k笔买入时的最优收益加上i日股价。i日k笔买入的最优收益是i日前某日第k-1笔卖出时收益减去i日股价。 |



---

### 背包问题

https://www.jianshu.com/p/d9a0624c05e7

| 问题序号 | 问题内容   | 思路解法 |
| -------- | ---------- | -------- |
| 332, 518 | 零钱兑换   |          |
| 474      | 一和零     |          |
| -        | 01背包问题 |          |
| -        | 完全背包   |          |
| -        | 多重背包   |          |



---



### 分治法

 - 分解（Divide）：将原问题分解成一系列子问题；
 - 解决（conquer）：递归地解各个子问题。若子问题足够小，则直接求解；
 - 合并（Combine）：将子问题的结果合并成原问题的解。

| 问题序号 | 问题内容  | 思路解法 |
| -------- | --------- | -------- |
| 50       | Pow(x, n) |          |
| 169, 229 | 求众数    |          |



---

### 贪心算法

https://www.jianshu.com/p/1e1a9a81bbc0

| 问题序号 | 问题内容       | 思路解法 |
| -------- | -------------- | -------- |
| 860      | 柠檬水找零     |          |
| 135      | 分发糖果       |          |
| 330      | 按要求补齐数组 |          |



---

### 哈希表

https://www.jianshu.com/p/d3a48852d5e3

 - 对数组进行分类时，可以采用哈系表来表达分类结果。

| 问题序号 | 问题内容         | 思路解法 |
| -------- | ---------------- | -------- |
| 1        | 两数之和         |          |
| 242      | 有效的字母异位词 |          |
| 15       | 三数之和         |          |



---

### 优先队列

https://www.jianshu.com/p/1bedaee726da

| 问题序号 | 问题内容                | 思路解法 |
| -------- | ----------------------- | -------- |
| 703 | 数据流中的第K大元素 |          |
| 239 | 滑动窗口最大值      |          |
| 692 | 前K个高频单词      |          |



---

### 栈和队列

https://www.jianshu.com/p/e231c0d3c05e

| 问题序号 | 问题内容       | 思路解法 |
| -------- | -------------- | -------- |
| 20 | 有效的括号 |          |
| 739 | 每日温度   |          |
| 394 | 字符串解码 |          |



---

### 树

https://www.jianshu.com/p/47e632985f11

- **树**是一种数据结构，它是由n>=1个有限结点组成一个具有层次关系的集合。没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树。

- **二叉树**是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉搜索树和二叉堆。

- **二叉搜索树**是具有下列性质的二叉树： 若它的左子树非空，则其所有结点的值均小于它的根结点的值； 若它的右子树非空，则其所有结点的值均大于它的根结点的值； 任意节点第左、右子树也是二叉搜索树。

- 一些经典的二叉树问题：

  - 二叉树前序遍历
    - 递归，按照**根-左-右**的方式递归。
    - 迭代，见代码。
    ```javascript
    var preorderTraversal = function(root){
        let treeStack = []
        let res = []
        while(root || treeStack.length){
            while(root){
                res.push(root.val)
                treeStack.push(root)
                root = root.left
            }
            if(treeStack.length){
                root = treeStack.pop()
                root = root.right
            }
        }
        return res
    }
    ```
    
  - 二叉树的中序遍历
  
    - 递归，按照**左-根-右**的方式递归。
    - 迭代，见代码。
    ```javascript
    var inorderTraversal = function(root){
        let treeStack = []
        let res = []
        while(root || treeStack.length){
            while(root){
                treeStack.push(root)
                root = root.left
            }
            if(treeStack.length){
                root = treeStack.pop()
                res.push(root.val)
                root = root.right
            }
        }
        return res
    }
    ```
    
  - 二叉树的后序遍历
  
    - 递归，按照**左-右-根**的方式递归。
    - 迭代，见代码。
    ```javascript
    var postorderTraversal = function(root) {
        if(!root) return []
        let treeStack = [root]
        let res = []
        let pre
        while(treeStack.length){
            root = treeStack[treeStack.length - 1]
            if((!root.left && !root.right) || (pre &&(pre == root.left || pre == root.right))){
                res.push(root.val)
                treeStack.pop()
                pre = root
            }else{
                if(root.right) treeStack.push(root.right)
                if(root.left) treeStack.push(root.left)
            }
        }
        return res
    }
    ```
  

| 问题序号 | 问题内容                 | 思路解法                                         |
| -------- | ------------------------ | ------------------------------------------------ |
| 226      | 二叉树翻转               | 用前序遍历对各节点的子节点进行翻转               |
| 144      | 二叉树前序遍历           | 递归，按照**根-左-右**的方式递归。               |
| 94       | 二叉树的中序遍历         | 递归，按照**左-根-右**的方式递归。               |
| 145      | 二叉树的后序遍历         | 递归，按照**左-右-根**的方式递归。               |
| 102, 107 | 二叉树的层次遍历         |                                                  |
| 987      | 二叉树的垂序遍历         |                                                  |
| 98       | 验证二叉搜索树           |                                                  |
| 110      | 验证平衡二叉树           | 递归，每个节点满足（左<=根）且（右>=根）则成立。 |
| 236      | 二叉树的最近公共祖先     |                                                  |
| 235      | 二叉搜索树的最近公共祖先 |                                                  |
| 538      | 搜索树转累加树           | 递归，按照**右-根-左**的方式递归。               |



### 二分法

| 问题序号 | 问题内容         | 思路解法                                           |
| -------- | ---------------- | -------------------------------------------------- |
| 35       | 搜索插入位置     | 二分法                                             |
| 33       | 搜索旋转排序数组 | 二分法，这题可以通过异或操作简化代码，但是烦的起飞 |
